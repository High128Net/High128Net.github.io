{"meta":{"title":"Charlie-Amao's Blog","subtitle":"Make A Difference To The World","description":"以梦为马 不负韶华","author":"Charlie-Amao","url":"http://high128net.github.io"},"pages":[{"title":"About Me","date":"2018-01-09T13:22:07.000Z","updated":"2018-03-08T05:52:53.705Z","comments":true,"path":"about/index.html","permalink":"http://high128net.github.io/about/index.html","excerpt":"","text":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 以梦为马，不负韶华&emsp;&emsp;边缘90后，BUPT CS master，后知后觉，摸爬滚打。热衷于大数据分析&amp;处理，人工智能，自然语言处理领域，研究方向为知识图谱的自动问答及Related关键技术。技术路线一度转变而学艺不精，目前专心在自然语言处理方向做深入研究与实践，关注研究领域有： 机器学习&amp;深度学习技术 自然语言处理基础研究 知识图谱 自动问答 信息抽取&amp;信息检索 对话系统&amp;聊天机器人 &emsp;&emsp;受到许多值得敬佩的技术爱好者和专家的影响，遂专心投入科研与应用工程实践，记录技术积累与成长过程。路漫漫其修远兮，吾将上下而求索，期待同大家共同学习与进步。 contact me： E-mail：cyzhang_259@sina.com Github 微信订阅号：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"}],"posts":[{"title":"面试篇-数据结构与算法（散列表）","slug":"面试篇-数据结构与算法（散列表）","date":"2018-01-30T05:40:22.154Z","updated":"2018-01-30T05:38:52.000Z","comments":true,"path":"2018/01/30/面试篇-数据结构与算法（散列表）/","link":"","permalink":"http://high128net.github.io/2018/01/30/面试篇-数据结构与算法（散列表）/","excerpt":"","text":"master,researcher,engineer.make a difference to the world.注：本文所涉及代码和方法均使用java。 数据结构散列表HashMap与HashTable的区别1、继承类不同，HashTable继承陈旧的Dictionary类，HashMap继承AbstractMap类，两者都实现了Map接口。2、HashTable是同步的，HashMap是非线性安全的，但可在多线程情况下使用Collections.synchronizedMap()方法实现同步。3、HashMap可以允许一个NULL的key，或者允许一个或多个NULL的value，而HashTable不允许存在NUll。4、HashMap可使用方法：containsKey()和containsValue()判断是否存在某一项。综上，我们建议使用HashMap，淘汰使用HashTable。 HashMap常用方法123456789//定义HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();//插入map.put(key,value);//查询map.get(key);//判断是否存在map.containsKey(key);map.containsValue(value); HashMap遍历方法1、遍历Map.entrySet()+Iterator：它的每一个元素都是Map.Entry对象，这个对象中，放着的就是Map中的某一对key-value；Iterator方法12345678910Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"key1\", \"value1\");map.put(\"key2\", \"value2\");map.put(\"key3\", \"value3\");Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.EntrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key:\" + entry.getKey()); System.out.println(\"value:\" + entry.getValue());&#125; for增强方法1234for(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123; System.out.println(\"key:\"+entry.getKey()); System.out.println(\"value:\"+entry.getValue()); &#125; 2、遍历Map.keySet()+for循环：它是Map中key值的集合，我们可以通过遍历这个集合来读取Map中的元素；12345678Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"key1\", \"value1\");map.put(\"key2\", \"value2\");map.put(\"key3\", \"value3\");for (String key : map.keySet()) &#123; System.out.println(\"key:\" + key); System.out.println(\"value:\" + map.get(key));&#125; 3、遍历Map.values()：它是Map中value的集合，我们可以直接通过这个集合遍历Map中的值，却不能读取key。123for(String value : map.values())&#123; System.out.println(value); &#125; 应用场景1、当需要对元素进行计数时，HashMap非常有用，如统计一个字符串中每个字符出现的次数，如控制台输入一句英语，简单统计各个单词出现的次数。2006年google的一道笔试题：在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。（用哈希表解题）方案：第一遍扫描这个数组时，每碰到一个字符，在哈希表中找到对应的项并把出现的次数增加一次。这样在进行第二次扫描时，就能直接从哈希表中得到每个字符出现的次数，遇到第一个value为1的即可返回该key。2、搜索引擎热点统计（海量数据的top K问题）通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。方案：第一步：查询统计（HashMap）维护一个Key为Query字串，Value为该Query出现次数的HashMap，每次读取一个Query，如果该字串不在Map中，那么加入该字串，并且将Value值设为1；如果该字串在Map中，那么将该字串的计数加1即可。第二步：找出TOP K，（top k大用最小堆；top k小用最大堆）构建一个K大小的最小堆，每次新来的value与堆的根节点value比较，如果小于根则丢弃，否则替换根，并进行最小堆的调整；并循环依次处理。3、HashMap的排序按照key排序：123456789101112131415161718//指定排序器TreeMap&lt;String, String&gt; treeMap2 = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() &#123; /* * int compare(Object o1, Object o2) 返回一个基本类型的整型， * 返回负数表示：o1 小于o2， * 返回0 表示：o1和o2相等， * 返回正数表示：o1大于o2。 */ public int compare(String o1, String o2) &#123; //指定排序器按照降序排列 return o2.compareTo(o1); &#125;&#125;);treeMap2.put(\"2\", \"1\");treeMap2.put(\"b\", \"1\");treeMap2.put(\"1\", \"1\");treeMap2.put(\"a\", \"1\");System.out.println(\"treeMap2=\" + treeMap2); 小结：1、TreeMap如不指定排序器，默认将按照key值进行升序排序，如果指定了排序器，则按照指定的排序器进行排序。2、具体的排序规则，开发人员可以在int compare()方法中进行指定。按照Value排序：123456789101112131415161718192021222324252627282930313233343536class ValueComparator implements Comparator&lt;String&gt; &#123; Map&lt;String, Integer&gt; base; public ValueComparator(Map&lt;String, Integer&gt; base) &#123; this.base = base; &#125; public int compare(String a, String b) &#123; if (base.get(a) &gt;= base.get(b)) &#123; return -1; &#125; else &#123; return 1; &#125; // returning 0 would merge keys &#125;&#125;public class Q12 &#123; public static void printMap(Map mp) &#123; Iterator it = mp.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry pairs = (Map.Entry) it.next(); System.out.println(pairs.getKey() + \" = \" + pairs.getValue()); it.remove(); // avoids a ConcurrentModificationException &#125; &#125; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; countMap = new HashMap&lt;String, Integer&gt;(); // add a lot of entries countMap.put(\"a\", 10); countMap.put(\"b\", 20); ValueComparator vc = new ValueComparator(countMap); TreeMap&lt;String, Integer&gt; sortedMap = new TreeMap&lt;String, Integer&gt;(vc); sortedMap.putAll(countMap); printMap(sortedMap); &#125;&#125; 注：使用了一个比较器Comparator对TreeMap排序，该比较器比较key的方式是取出key对应的value进行大小比较；4、哈希表算法面试题，参考博客链接","categories":[{"name":"面试","slug":"面试","permalink":"http://high128net.github.io/categories/面试/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://high128net.github.io/tags/数据结构与算法/"}]},{"title":"面试篇-数据结构与算法（数组）","slug":"面试篇-数据结构与算法（数组）","date":"2018-01-29T13:31:44.207Z","updated":"2018-01-29T13:31:12.000Z","comments":true,"path":"2018/01/29/面试篇-数据结构与算法（数组）/","link":"","permalink":"http://high128net.github.io/2018/01/29/面试篇-数据结构与算法（数组）/","excerpt":"","text":"master,researcher,engineer.make a difference to the world.注：本文所涉及代码和方法均使用java。 数据结构数组1.1 定义数组格式一：元素类型[] 数组名 = new 元素类型[元素个数或数组长度];格式二：元素类型[] 数组名 = new 元素类型[]{元素，元素，……};12345//定义了一个数组，并且指定了数组的长度，我们这里称它为动态定义String[] aArray = new String[5];//在分配内存空间的同时还初始化了值String[] bArray = &#123;\"a\",\"b\",\"c\", \"d\", \"e\"&#125;;String[] cArray = new String[]&#123;\"a\",\"b\",\"c\",\"d\",\"e\"&#125;; 注：给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小。可以使用length属性获取数组的大小。 注：下列写法是错误的12int[] arr;arr=&#123;1,2,3,4,5&#125;; 1.2 打印数组元素使用方法1：Arrays.toString(array)123int[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;String intArrayString = Arrays.toString(intArray);System.out.println(intArrayString); 使用方法2：字符串的形式输出,StringUtils.join()12String[] stringArray = &#123;\"a\", \"b\", \"c\", \"d\", \"e\"&#125;;System.out.println(StringUtils.join(Arrays.asList(stringArray),\",\")); 1.3 从Array中创建动态数组ArrayList：使用方法：new ArrayList&lt;&gt;(Arrays.asList(array))123String[] stringArray = &#123; \"a\", \"b\", \"c\", \"d\", \"e\" &#125;;ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(stringArray));System.out.println(arrayList); 1.4 ArrayList转为数组使用方法：arrayList.toArray() 1.5 将Array转成Set集合Set集合可自动去重，排序。1234String[] stringArray = &#123;\"a\",\"e\",\"c\",\"b\",\"a\",\"c\"&#125;;Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(stringArray));System.out.println(set);//输出[a, b, c, e] 1.6 java.util.Arrays类常用方法：123456789Arrays.toString()Arrays.deepToString()Arrays.asList()Arrays.sort()，（注：可考虑带上new Comparator&lt;Integer&gt;() &#123;&#125;自定义比较器情况）Arrays.copyOf()Arrays.copyOfRange()Arrays.binarySearch()Arrays.equals()Arrays.deepEquals() 1.7 二维数组的初始化静态初始化1int intArray[ ][ ]=&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;3,4,5&#125;&#125;; Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。动态初始化1int[][] a = new int[2][3]; 二维简单数据类型数组的动态初始化1234567String s[][] = new String[2][];s[0] = new String[2];//为最高维分配引用空间 s[1] = new String[2]; //为最高维分配引用空间 s[0][0] = new String(\"Good\");// 为每个数组元素单独分配空间 s[0][1] = new String(\"Luck\");// 为每个数组元素单独分配空间 s[1][0] = new String(\"to\");// 为每个数组元素单独分配空间 s[1][1] = new String(\"You\");// 为每个数组元素单独分配空间 对二维复合数据类型的数组，必须首先为最高维分配引用空间，然后再顺次为低维分配空间。而且，必须为每个数组元素单独分配空间。 1.8 ArrayList（动态数组）大小：arrayList.size()遍历方式：迭代器遍历1234Iterator&lt;Integer&gt; it = arrayList.iterator();while(it.hasNext())&#123; System.out.print(it.next() + \" \");&#125; 索引值遍历123for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.print(arrayList.get(i) + \" \");&#125; for循环遍历123for(Integer number : arrayList)&#123; System.out.print(number + \" \");&#125; 常用方法：12345678910111213141516171819//定义ArrayList&lt;Integer&gt; intArrayList = new ArrayList&lt;&gt;();ArrayList&lt;Integer&gt; intArrayList = new ArrayList&lt;&gt;(Arrays.asList(intArray));//新增intArrayList.add(E e)intArrayList.add(int index, E element)intArrayList.addAll(Collection&lt;? extends E&gt; c)intArrayList.addAll(int index, Collection&lt;? extends E&gt; c)//更新intArrayList.set(int index, E element)//删除intArrayList.remove(int index)intArrayList.remove(Object o)intArrayList.removeRange(int fromIndex, int toIndex)intArrayList.removeAll()//查找intArrayList.get(int index)//扩容Arrays.copyOf(intArrayList,newSize)","categories":[{"name":"面试","slug":"面试","permalink":"http://high128net.github.io/categories/面试/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://high128net.github.io/tags/数据结构与算法/"}]},{"title":"Neo4j-Cypher语言编程","slug":"Neo4j-Cypher语言编程","date":"2018-01-12T12:35:32.000Z","updated":"2018-01-14T09:23:28.113Z","comments":true,"path":"2018/01/12/Neo4j-Cypher语言编程/","link":"","permalink":"http://high128net.github.io/2018/01/12/Neo4j-Cypher语言编程/","excerpt":"","text":"master,researcher,engineer.make a difference to the world.Neo4j Cypher语言编程cypher 语言","categories":[{"name":"KnowledgeGraph","slug":"KnowledgeGraph","permalink":"http://high128net.github.io/categories/KnowledgeGraph/"}],"tags":[{"name":"Cypher","slug":"Cypher","permalink":"http://high128net.github.io/tags/Cypher/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-10T03:42:00.959Z","updated":"2018-01-10T03:42:00.958Z","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"http://high128net.github.io/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}